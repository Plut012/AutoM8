<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Workflow Builder</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
        }
        
        .app-container {
            display: flex;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        
        .sidebar {
            width: 320px;
            background: rgba(26, 26, 46, 0.9);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.2);
        }
        
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .toolbar {
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 10px;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: 
                radial-gradient(circle at 25% 25%, rgba(59, 130, 246, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(168, 85, 247, 0.1) 0%, transparent 50%),
                linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            background-size: 100px 100px;
            background-image: 
                linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
        }
        
        .canvas {
            position: absolute;
            width: 5000px;
            height: 5000px;
            cursor: grab;
        }
        
        .canvas:active {
            cursor: grabbing;
        }
        
        .block-template {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            cursor: grab;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .block-template:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(59, 130, 246, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .block-template-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
            color: #ffffff;
        }
        
        .block-template-desc {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.4;
        }
        
        .block {
            position: absolute;
            background: rgba(30, 41, 59, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            min-width: 180px;
            cursor: move;
            user-select: none;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .block:hover {
            border-color: rgba(59, 130, 246, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
        }
        
        .block.selected {
            border-color: #3b82f6;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.4);
        }
        
        .block-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 8px;
            text-align: center;
            color: #ffffff;
        }
        
        .block-status {
            font-size: 10px;
            text-align: center;
            padding: 2px 8px;
            border-radius: 6px;
            margin-top: 8px;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .block-status.idle { color: #94a3b8; }
        .block-status.running { 
            color: #fbbf24; 
            background: rgba(251, 191, 36, 0.1);
            animation: pulse 2s infinite;
        }
        .block-status.completed { 
            color: #10b981; 
            background: rgba(16, 185, 129, 0.1);
        }
        .block-status.error { 
            color: #ef4444; 
            background: rgba(239, 68, 68, 0.1);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .port {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            position: absolute;
            cursor: crosshair;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .port:hover {
            transform: scale(1.2);
            border-color: rgba(255, 255, 255, 0.8);
        }
        
        .input-port {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            left: -8px;
            top: 50%;
            transform: translateY(-50%);
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.3);
        }
        
        .output-port {
            background: linear-gradient(135deg, #10b981, #059669);
            right: -8px;
            top: 50%;
            transform: translateY(-50%);
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.3);
        }
        
        .connection {
            stroke: url(#connectionGradient);
            stroke-width: 3;
            fill: none;
            filter: drop-shadow(0 0 6px rgba(59, 130, 246, 0.3));
            animation: flow 3s linear infinite;
        }
        
        @keyframes flow {
            0% { stroke-dasharray: 10 5; stroke-dashoffset: 0; }
            100% { stroke-dasharray: 10 5; stroke-dashoffset: 15; }
        }
        
        .btn {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 14px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .btn:hover {
            background: linear-gradient(135deg, #2563eb, #1e40af);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #64748b, #475569);
        }
        
        .btn-secondary:hover {
            background: linear-gradient(135deg, #475569, #334155);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }
        
        .btn-danger:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
        }
        
        .btn-success:hover {
            background: linear-gradient(135deg, #059669, #047857);
        }
        
        .form-group {
            margin-bottom: 16px;
        }
        
        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .form-input {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .form-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
            background: rgba(0, 0, 0, 0.5);
        }
        
        .form-textarea {
            resize: vertical;
            min-height: 80px;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        
        .config-panel {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .config-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 16px;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .output-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 250px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            transition: transform 0.3s ease;
        }
        
        .output-panel.collapsed {
            transform: translateY(200px);
        }
        
        .output-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .output-content {
            line-height: 1.6;
        }
        
        .log-entry {
            margin-bottom: 12px;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid;
        }
        
        .log-entry.info {
            background: rgba(59, 130, 246, 0.1);
            border-color: #3b82f6;
            color: #93c5fd;
        }
        
        .log-entry.success {
            background: rgba(16, 185, 129, 0.1);
            border-color: #10b981;
            color: #6ee7b7;
        }
        
        .log-entry.error {
            background: rgba(239, 68, 68, 0.1);
            border-color: #ef4444;
            color: #fca5a5;
        }
        
        .log-entry.warning {
            background: rgba(251, 191, 36, 0.1);
            border-color: #fbbf24;
            color: #fde68a;
        }
        
        .login-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .login-form {
            background: rgba(30, 41, 59, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        .login-title {
            font-size: 24px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 32px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 24px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 4px;
        }
        
        .tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .tab.active {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
        }
        
        .floating-action {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 8px 30px rgba(59, 130, 246, 0.3);
            transition: all 0.3s ease;
            z-index: 100;
        }
        
        .floating-action:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 40px rgba(59, 130, 246, 0.4);
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
            white-space: nowrap;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin: 12px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            transition: width 0.3s ease;
        }
        
        .minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }
        
        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 14px;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 16px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .notification.success {
            background: rgba(16, 185, 129, 0.1);
            border-color: #10b981;
            color: #6ee7b7;
        }
        
        .notification.error {
            background: rgba(239, 68, 68, 0.1);
            border-color: #ef4444;
            color: #fca5a5;
        }
        
        .workflow-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .workflow-title {
            font-size: 18px;
            font-weight: 600;
            color: #ffffff;
        }
        
        .workflow-subtitle {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // API Configuration
        const API_BASE = 'http://localhost:8000';
        
        // Utility Functions
        const generateId = () => Math.random().toString(36).substr(2, 9);
        
        const getAuthToken = () => localStorage.getItem('authToken');
        
        const apiCall = async (endpoint, options = {}) => {
            const token = getAuthToken();
            const config = {
                headers: {
                    'Content-Type': 'application/json',
                    ...(token && { Authorization: `Bearer ${token}` }),
                    ...options.headers
                },
                ...options
            };
            
            const response = await fetch(`${API_BASE}${endpoint}`, config);
            
            if (!response.ok) {
                const error = await response.text();
                throw new Error(error);
            }
            
            return response.json();
        };

        // Components
        const LoginModal = ({ isOpen, onClose, onLogin }) => {
            const [activeTab, setActiveTab] = useState('login');
            const [formData, setFormData] = useState({
                username: '',
                email: '',
                password: ''
            });
            const [loading, setLoading] = useState(false);

            const handleSubmit = async (e) => {
                e.preventDefault();
                setLoading(true);
                
                try {
                    if (activeTab === 'login') {
                        const response = await apiCall('/auth/login', {
                            method: 'POST',
                            body: JSON.stringify({
                                username: formData.username,
                                password: formData.password
                            })
                        });
                        
                        localStorage.setItem('authToken', response.access_token);
                        onLogin(response);
                    } else {
                        await apiCall('/auth/register', {
                            method: 'POST',
                            body: JSON.stringify(formData)
                        });
                        
                        setActiveTab('login');
                        setFormData(prev => ({ ...prev, email: '', password: '' }));
                    }
                } catch (error) {
                    console.error('Auth error:', error);
                } finally {
                    setLoading(false);
                }
            };

            if (!isOpen) return null;

            return (
                <div className="login-modal">
                    <form className="login-form" onSubmit={handleSubmit}>
                        <h2 className="login-title">LLM Workflow Builder</h2>
                        
                        <div className="tabs">
                            <div 
                                className={`tab ${activeTab === 'login' ? 'active' : ''}`}
                                onClick={() => setActiveTab('login')}
                            >
                                Login
                            </div>
                            <div 
                                className={`tab ${activeTab === 'register' ? 'active' : ''}`}
                                onClick={() => setActiveTab('register')}
                            >
                                Register
                            </div>
                        </div>

                        <div className="form-group">
                            <label className="form-label">Username</label>
                            <input
                                type="text"
                                className="form-input"
                                value={formData.username}
                                onChange={(e) => setFormData(prev => ({ ...prev, username: e.target.value }))}
                                required
                            />
                        </div>

                        {activeTab === 'register' && (
                            <div className="form-group">
                                <label className="form-label">Email</label>
                                <input
                                    type="email"
                                    className="form-input"
                                    value={formData.email}
                                    onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
                                    required
                                />
                            </div>
                        )}

                        <div className="form-group">
                            <label className="form-label">Password</label>
                            <input
                                type="password"
                                className="form-input"
                                value={formData.password}
                                onChange={(e) => setFormData(prev => ({ ...prev, password: e.target.value }))}
                                required
                            />
                        </div>

                        <button type="submit" className="btn" disabled={loading} style={{width: '100%', marginTop: '20px'}}>
                            {loading ? 'Loading...' : (activeTab === 'login' ? 'Login' : 'Register')}
                        </button>
                    </form>
                </div>
            );
        };

        const BlockTemplate = ({ type, name, description, onDragStart }) => {
            return (
                <div
                    className="block-template"
                    draggable
                    onDragStart={(e) => onDragStart(e, type)}
                >
                    <div className="block-template-title">{name}</div>
                    <div className="block-template-desc">{description}</div>
                </div>
            );
        };

        const Block = ({ 
            block, 
            position, 
            selected, 
            onSelect, 
            onMove, 
            onPortClick, 
            status = 'idle' 
        }) => {
            const blockRef = useRef();
            const [isDragging, setIsDragging] = useState(false);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });

            const handleMouseDown = (e) => {
                if (e.target.classList.contains('port')) return;
                
                const rect = blockRef.current.getBoundingClientRect();
                setDragOffset({
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                });
                setIsDragging(true);
                onSelect(block.id);
            };

            const handleMouseMove = useCallback((e) => {
                if (!isDragging) return;
                
                onMove(block.id, {
                    x: e.clientX - dragOffset.x,
                    y: e.clientY - dragOffset.y
                });
            }, [isDragging, dragOffset, block.id, onMove]);

            const handleMouseUp = useCallback(() => {
                setIsDragging(false);
            }, []);

            useEffect(() => {
                if (isDragging) {
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                    return () => {
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                    };
                }
            }, [isDragging, handleMouseMove, handleMouseUp]);

            return (
                <div
                    ref={blockRef}
                    className={`block ${selected ? 'selected' : ''}`}
                    style={{
                        left: position.x,
                        top: position.y,
                        zIndex: isDragging ? 1000 : 1
                    }}
                    onMouseDown={handleMouseDown}
                >
                    <div className="block-title">{block.name}</div>
                    <div className={`block-status ${status}`}>
                        {status === 'running' ? 'Running...' : status}
                    </div>
                    
                    {block.type !== 'input' && (
                        <div 
                            className="port input-port" 
                            data-port="input"
                            onClick={(e) => onPortClick(e, block.id, 'input')}
                        />
                    )}
                    
                    {block.type !== 'output' && (
                        <div 
                            className="port output-port" 
                            data-port="output"
                            onClick={(e) => onPortClick(e, block.id, 'output')}
                        />
                    )}
                </div>
            );
        };

        const ConfigPanel = ({ selectedBlock, blockTypes, onConfigUpdate }) => {
            const [config, setConfig] = useState({});

            useEffect(() => {
                if (selectedBlock) {
                    setConfig(selectedBlock.config || {});
                }
            }, [selectedBlock]);

            const handleConfigChange = (key, value) => {
                const newConfig = { ...config, [key]: value };
                setConfig(newConfig);
                onConfigUpdate(selectedBlock.id, newConfig);
            };

            if (!selectedBlock) {
                return (
                    <div className="config-panel">
                        <div className="config-title">Configuration</div>
                        <p style={{ color: 'rgba(255,255,255,0.6)', textAlign: 'center' }}>
                            Select a block to configure
                        </p>
                    </div>
                );
            }

            const blockType = blockTypes[selectedBlock.type];
            if (!blockType || !blockType.config) {
                return (
                    <div className="config-panel">
                        <div className="config-title">{selectedBlock.name}</div>
                        <p style={{ color: 'rgba(255,255,255,0.6)' }}>
                            No configuration available for this block type.
                        </p>
                    </div>
                );
            }

            return (
                <div className="config-panel">
                    <div className="config-title">
                        {selectedBlock.name} Configuration
                    </div>
                    
                    {Object.entries(blockType.config).map(([key, fieldConfig]) => (
                        <div key={key} className="form-group">
                            <label className="form-label">{fieldConfig.label}</label>
                            
                            {fieldConfig.type === 'textarea' ? (
                                <textarea
                                    className="form-input form-textarea"
                                    value={config[key] || fieldConfig.default || ''}
                                    onChange={(e) => handleConfigChange(key, e.target.value)}
                                    rows={4}
                                />
                            ) : fieldConfig.type === 'select' ? (
                                <select
                                    className="form-input"
                                    value={config[key] || fieldConfig.default || ''}
                                    onChange={(e) => handleConfigChange(key, e.target.value)}
                                >
                                    {fieldConfig.options.map(option => (
                                        <option key={option} value={option}>{option}</option>
                                    ))}
                                </select>
                            ) : fieldConfig.type === 'number' ? (
                                <input
                                    type="number"
                                    className="form-input"
                                    value={config[key] || fieldConfig.default || 0}
                                    onChange={(e) => handleConfigChange(key, parseFloat(e.target.value))}
                                    min={fieldConfig.min}
                                    max={fieldConfig.max}
                                    step={fieldConfig.step}
                                />
                            ) : (
                                <input
                                    type="text"
                                    className="form-input"
                                    value={config[key] || fieldConfig.default || ''}
                                    onChange={(e) => handleConfigChange(key, e.target.value)}
                                />
                            )}
                        </div>
                    ))}
                </div>
            );
        };

        const OutputPanel = ({ logs, isCollapsed, onToggle }) => {
            const outputRef = useRef();

            useEffect(() => {
                if (outputRef.current) {
                    outputRef.current.scrollTop = outputRef.current.scrollHeight;
                }
            }, [logs]);

            return (
                <div className={`output-panel ${isCollapsed ? 'collapsed' : ''}`}>
                    <div className="output-header">
                        <h3>Execution Output</h3>
                        <button className="btn btn-secondary" onClick={onToggle}>
                            {isCollapsed ? 'Show' : 'Hide'}
                        </button>
                    </div>
                    
                    <div ref={outputRef} className="output-content">
                        {logs.length === 0 ? (
                            <div style={{ color: 'rgba(255,255,255,0.6)', textAlign: 'center', marginTop: '40px' }}>
                                Output will appear here when you run a workflow
                            </div>
                        ) : (
                            logs.map((log, index) => (
                                <div key={index} className={`log-entry ${log.level}`}>
                                    <strong>[{log.timestamp}]</strong> {log.message}
                                    {log.data && (
                                        <pre style={{ marginTop: '8px', fontSize: '11px', opacity: 0.8 }}>
                                            {JSON.stringify(log.data, null, 2)}
                                        </pre>
                                    )}
                                </div>
                            ))
                        )}
                    </div>
                </div>
            );
        };

        const WorkflowBuilder = () => {
            const [user, setUser] = useState(null);
            const [showLogin, setShowLogin] = useState(false);
            const [blocks, setBlocks] = useState({});
            const [connections, setConnections] = useState([]);
            const [selectedBlock, setSelectedBlock] = useState(null);
            const [blockTypes, setBlockTypes] = useState({});
            const [logs, setLogs] = useState([]);
            const [isExecuting, setIsExecuting] = useState(false);
            const [executionProgress, setExecutionProgress] = useState(0);
            const [blockStatuses, setBlockStatuses] = useState({});
            const [outputCollapsed, setOutputCollapsed] = useState(false);
            const [panOffset, setPanOffset] = useState({ x: 0, y: 0 });
            const [connectingFrom, setConnectingFrom] = useState(null);
            const [notifications, setNotifications] = useState([]);

            const canvasRef = useRef();
            const svgRef = useRef();

            // Initialize
            useEffect(() => {
                const token = getAuthToken();
                if (token) {
                    // Validate token and get user info
                    setUser({ username: 'User' }); // Simplified for demo
                } else {
                    setShowLogin(true);
                }

                // Load block types
                loadBlockTypes();
            }, []);

            const loadBlockTypes = async () => {
                try {
                    const types = await apiCall('/block-types');
                    setBlockTypes(types);
                } catch (error) {
                    console.error('Failed to load block types:', error);
                }
            };

            const addNotification = (message, type = 'info') => {
                const id = generateId();
                const notification = { id, message, type };
                setNotifications(prev => [...prev, notification]);
                
                setTimeout(() => {
                    setNotifications(prev => prev.filter(n => n.id !== id));
                }, 5000);
            };

            const addLog = (message, level = 'info', data = null) => {
                const timestamp = new Date().toLocaleTimeString();
                setLogs(prev => [...prev, { timestamp, message, level, data }]);
            };

            const handleLogin = (loginData) => {
                setUser({ username: loginData.username || 'User' });
                setShowLogin(false);
                addNotification('Successfully logged in!', 'success');
            };

            const handleLogout = () => {
                localStorage.removeItem('authToken');
                setUser(null);
                setShowLogin(true);
                setBlocks(prev => ({
                    ...prev,
                    [blockId]: {
                        ...newBlock,
                        position: { x, y }
                    }
                }));

                addLog(`Added ${blockTypes[blockType].name} block`, 'info');
            };

            const handleBlockMove = (blockId, newPosition) => {
                setBlocks(prev => ({
                    ...prev,
                    [blockId]: {
                        ...prev[blockId],
                        position: newPosition
                    }
                }));
            };

            const handleBlockSelect = (blockId) => {
                setSelectedBlock(blocks[blockId] || null);
            };

            const handleConfigUpdate = (blockId, newConfig) => {
                setBlocks(prev => ({
                    ...prev,
                    [blockId]: {
                        ...prev[blockId],
                        config: newConfig
                    }
                }));
            };

            const handlePortClick = (e, blockId, portType) => {
                e.stopPropagation();
                
                if (portType === 'output') {
                    setConnectingFrom({ blockId, port: portType });
                } else if (portType === 'input' && connectingFrom) {
                    // Create connection
                    if (connectingFrom.blockId !== blockId) {
                        const connectionId = generateId();
                        const newConnection = {
                            id: connectionId,
                            from: connectingFrom.blockId,
                            to: blockId
                        };
                        
                        setConnections(prev => [...prev, newConnection]);
                        addLog(`Connected ${blocks[connectingFrom.blockId]?.name} to ${blocks[blockId]?.name}`, 'info');
                    }
                    setConnectingFrom(null);
                }
            };

            const executeWorkflow = async () => {
                if (Object.keys(blocks).length === 0) {
                    addNotification('No blocks in workflow', 'error');
                    return;
                }

                setIsExecuting(true);
                setExecutionProgress(0);
                setBlockStatuses({});
                addLog('Starting workflow execution...', 'info');

                try {
                    const workflowData = {
                        blocks: Object.values(blocks).map(block => ({
                            type: block.type,
                            position: block.position,
                            config: { ...block.config, id: block.id }
                        })),
                        connections: connections.map(conn => ({
                            from: conn.from,
                            to: conn.to
                        })),
                        input_data: {}
                    };

                    // Simulate execution progress
                    const totalBlocks = Object.keys(blocks).length;
                    let completedBlocks = 0;

                    for (const blockId of Object.keys(blocks)) {
                        setBlockStatuses(prev => ({ ...prev, [blockId]: 'running' }));
                        
                        // Simulate block execution time
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        
                        setBlockStatuses(prev => ({ ...prev, [blockId]: 'completed' }));
                        completedBlocks++;
                        setExecutionProgress((completedBlocks / totalBlocks) * 100);
                        
                        addLog(`Completed execution of ${blocks[blockId].name}`, 'success');
                    }

                    const result = await apiCall('/workflows/execute', {
                        method: 'POST',
                        body: JSON.stringify(workflowData)
                    });

                    addLog('Workflow execution completed successfully!', 'success', result.results);
                    addNotification('Workflow executed successfully!', 'success');

                } catch (error) {
                    addLog(`Workflow execution failed: ${error.message}`, 'error');
                    addNotification('Workflow execution failed', 'error');
                    
                    // Mark all running blocks as error
                    setBlockStatuses(prev => {
                        const updated = { ...prev };
                        Object.keys(updated).forEach(id => {
                            if (updated[id] === 'running') {
                                updated[id] = 'error';
                            }
                        });
                        return updated;
                    });
                } finally {
                    setIsExecuting(false);
                    setExecutionProgress(0);
                }
            };

            const clearWorkflow = () => {
                if (Object.keys(blocks).length === 0) return;
                
                if (confirm('Clear all blocks and connections?')) {
                    setBlocks({});
                    setConnections([]);
                    setSelectedBlock(null);
                    setBlockStatuses({});
                    setLogs([]);
                    addLog('Workflow cleared', 'info');
                }
            };

            const deleteSelectedBlock = () => {
                if (!selectedBlock) return;
                
                const blockId = selectedBlock.id;
                
                // Remove block
                setBlocks(prev => {
                    const updated = { ...prev };
                    delete updated[blockId];
                    return updated;
                });
                
                // Remove connections
                setConnections(prev => 
                    prev.filter(conn => conn.from !== blockId && conn.to !== blockId)
                );
                
                setSelectedBlock(null);
                addLog(`Deleted ${selectedBlock.name} block`, 'info');
            };

            // Keyboard shortcuts
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'Delete' && selectedBlock) {
                        deleteSelectedBlock();
                    } else if (e.key === 'Escape') {
                        setSelectedBlock(null);
                        setConnectingFrom(null);
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                        executeWorkflow();
                    }
                };

                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, [selectedBlock]);

            // Canvas panning
            const handleCanvasMouseDown = (e) => {
                if (e.target === canvasRef.current) {
                    // Start panning
                }
            };

            if (showLogin) {
                return <LoginModal isOpen={true} onClose={() => {}} onLogin={handleLogin} />;
            }

            return (
                <div className="app-container">
                    {/* Notifications */}
                    {notifications.map(notification => (
                        <div key={notification.id} className={`notification ${notification.type}`}>
                            {notification.message}
                        </div>
                    ))}

                    {/* Sidebar */}
                    <div className="sidebar">
                        <div className="sidebar-header">
                            <div className="workflow-header">
                                <div className="user-avatar">
                                    {user?.username?.[0]?.toUpperCase() || 'U'}
                                </div>
                                <div>
                                    <div className="workflow-title">Workflow Builder</div>
                                    <div className="workflow-subtitle">Welcome, {user?.username}</div>
                                </div>
                            </div>
                        </div>

                        <div className="sidebar-content">
                            <h3 style={{ marginBottom: '16px', fontSize: '16px', fontWeight: '600' }}>
                                Block Library
                            </h3>
                            
                            {Object.entries(blockTypes).map(([type, config]) => (
                                <BlockTemplate
                                    key={type}
                                    type={type}
                                    name={config.name}
                                    description={config.description}
                                    onDragStart={handleBlockDragStart}
                                />
                            ))}

                            <h3 style={{ marginTop: '32px', marginBottom: '16px', fontSize: '16px', fontWeight: '600' }}>
                                Controls
                            </h3>
                            
                            <button 
                                className="btn btn-success" 
                                onClick={executeWorkflow}
                                disabled={isExecuting}
                                style={{ width: '100%', marginBottom: '8px' }}
                            >
                                {isExecuting ? '⏳ Running...' : '▶️ Run Workflow'}
                            </button>
                            
                            <button 
                                className="btn btn-secondary" 
                                onClick={clearWorkflow}
                                style={{ width: '100%', marginBottom: '8px' }}
                            >
                                🗑️ Clear All
                            </button>
                            
                            <button 
                                className="btn btn-danger" 
                                onClick={handleLogout}
                                style={{ width: '100%' }}
                            >
                                🚪 Logout
                            </button>

                            {isExecuting && (
                                <div style={{ marginTop: '16px' }}>
                                    <div className="form-label">Execution Progress</div>
                                    <div className="progress-bar">
                                        <div 
                                            className="progress-fill" 
                                            style={{ width: `${executionProgress}%` }}
                                        />
                                    </div>
                                    <div style={{ fontSize: '12px', color: 'rgba(255,255,255,0.7)', textAlign: 'center' }}>
                                        {Math.round(executionProgress)}%
                                    </div>
                                </div>
                            )}

                            <ConfigPanel
                                selectedBlock={selectedBlock}
                                blockTypes={blockTypes}
                                onConfigUpdate={handleConfigUpdate}
                            />
                        </div>
                    </div>

                    {/* Main Content */}
                    <div className="main-content">
                        <div className="toolbar">
                            <h2 style={{ fontSize: '18px', fontWeight: '600', margin: 0 }}>
                                My Workflow
                            </h2>
                            <div style={{ flex: 1 }} />
                            <span style={{ fontSize: '12px', color: 'rgba(255,255,255,0.6)' }}>
                                {Object.keys(blocks).length} blocks, {connections.length} connections
                            </span>
                        </div>

                        <div 
                            className="canvas-container"
                            onDrop={handleCanvasDrop}
                            onDragOver={(e) => e.preventDefault()}
                            onMouseDown={handleCanvasMouseDown}
                        >
                            {/* Canvas */}
                            <div 
                                ref={canvasRef}
                                className="canvas"
                                style={{ transform: `translate(${panOffset.x}px, ${panOffset.y}px)` }}
                            >
                                {/* SVG for connections */}
                                <svg 
                                    ref={svgRef}
                                    style={{ 
                                        position: 'absolute', 
                                        top: 0, 
                                        left: 0, 
                                        width: '100%', 
                                        height: '100%',
                                        pointerEvents: 'none'
                                    }}
                                >
                                    <defs>
                                        <linearGradient id="connectionGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                            <stop offset="0%" stopColor="#10b981" />
                                            <stop offset="100%" stopColor="#3b82f6" />
                                        </linearGradient>
                                    </defs>
                                    <g>
                                        {connections.map(connection => {
                                            const fromBlock = blocks[connection.from];
                                            const toBlock = blocks[connection.to];
                                            
                                            if (!fromBlock || !toBlock) return null;
                                            
                                            const x1 = fromBlock.position.x + 180;
                                            const y1 = fromBlock.position.y + 50;
                                            const x2 = toBlock.position.x;
                                            const y2 = toBlock.position.y + 50;
                                            
                                            const dx = Math.abs(x2 - x1) * 0.5;
                                            const path = `M ${x1} ${y1} C ${x1 + dx} ${y1}, ${x2 - dx} ${y2}, ${x2} ${y2}`;
                                            
                                            return (
                                                <path
                                                    key={connection.id}
                                                    d={path}
                                                    className="connection"
                                                />
                                            );
                                        })}
                                    </g>
                                </svg>

                                {/* Blocks */}
                                {Object.values(blocks).map(block => (
                                    <Block
                                        key={block.id}
                                        block={block}
                                        position={block.position}
                                        selected={selectedBlock?.id === block.id}
                                        onSelect={handleBlockSelect}
                                        onMove={handleBlockMove}
                                        onPortClick={handlePortClick}
                                        status={blockStatuses[block.id] || 'idle'}
                                    />
                                ))}
                            </div>

                            {/* Minimap */}
                            <div className="minimap">
                                {/* Simplified minimap view */}
                                <div style={{ 
                                    padding: '8px', 
                                    fontSize: '10px', 
                                    color: 'rgba(255,255,255,0.6)' 
                                }}>
                                    Minimap
                                    <br />
                                    {Object.keys(blocks).length} blocks
                                </div>
                            </div>
                        </div>

                        <OutputPanel
                            logs={logs}
                            isCollapsed={outputCollapsed}
                            onToggle={() => setOutputCollapsed(!outputCollapsed)}
                        />
                    </div>

                    {/* Floating Action Button */}
                    <button 
                        className="floating-action"
                        onClick={() => addNotification('Feature coming soon!', 'info')}
                        title="Quick Actions"
                    >
                        ⚡
                    </button>
                </div>
            );
        };

        // Render the app
        ReactDOM.render(<WorkflowBuilder />, document.getElementById('root'));
    </script>
</body>
</html>{});
                setConnections([]);
                setLogs([]);
            };

            const handleBlockDragStart = (e, blockType) => {
                e.dataTransfer.setData('blockType', blockType);
            };

            const handleCanvasDrop = (e) => {
                e.preventDefault();
                const blockType = e.dataTransfer.getData('blockType');
                if (!blockType || !blockTypes[blockType]) return;

                const rect = canvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left - panOffset.x;
                const y = e.clientY - rect.top - panOffset.y;

                const blockId = generateId();
                const newBlock = {
                    id: blockId,
                    type: blockType,
                    name: blockTypes[blockType].name,
                    config: Object.entries(blockTypes[blockType].config || {}).reduce((acc, [key, field]) => {
                        acc[key] = field.default || '';
                        return acc;
                    }, {})
                };

                setBlocks(
